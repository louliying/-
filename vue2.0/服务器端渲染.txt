1. 基础概念：
	将同一个组件渲染为服务器端的HTML字符串，将它们发送到浏览器端， 同时将这些静态标记“激活”。

	服务器端渲染的Vue.js应用程序，称为“同构” “通用”。 这类应用程序的大部分代码，都可以在服务器和客户端，运行。

2. 服务器端渲染：
	使用SSR（服务器端渲染）， 与传统的SPA（单页面应用程序， Single-page-allication）相比，有以下优点：
	1. SEO友好
	2. 更快的内容到达时间（time-to-content）：无需等待所有的JS都完成下载并执行。
	缺点：
	1. 有些扩展库，需要特殊处理，才能在服务器端运行。 浏览器端的应用，只能在某些生命周期钩子中使用， 不需要特殊处理。
	2. 需要额外的服务器部署： node.js  server 运行环境 
							SPA只需要部署在静态文件服务器上
3. 预渲染 Prerendering
	如果对SEO友好的页面，只是一些about, concat等宣传页面，可用预渲染
	无需使用web服务器实时动态编译html，在构建时（build），生成特定路由的静态html文件。
	可使用prerender-spa-plugin 

4. 基本用法：
	1. 安装： npm install vue-server-renderer --save-dev
			 vue-server-renderer 和 vue的版本必须匹配， 不然运行会报错
			 vue-server-renderer 依赖一些node.js原生模块

5. 编写通用代码：
	即客户端服务器端都可运行的代码。

	1. 组件生命周期钩子函数：
		因为没有动态更新， 所以，只有beforeCreate 和 created 二个钩子会在服务器端渲染中被调用。
		其他钩子函数只会在客户端执行。

		在服务器端中， 在beforeCreated, created中， 要避免产生全局副作用的代码，如setInterval。
		在客户端，计时器可以在detroyed, beforeDestroy中，将其销毁， 但SSR中，并不会调用这些钩子，计时器就不会被销毁了。
		所以将这些副作用代码，放到beforeMount, mounted这类，客户端运行的钩子里。

	2. 访问特定平台API
		服务器端不能访问window, document这类仅浏览器可用的变量，在服务器端会抛错。

		对于仅浏览器可用的API，在纯客户端的生命周期钩子函数中，惰性访问它们。
		如果是第三方library，将其集成到服务器端渲染的应用程序中， 可能会很棘手。

	3. 自定义指令：
		大多数指令都是直接操作DOM， 会在服务器端渲染过程中导致错误。可以如下解决:
			a. 推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。
			b. 如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 directives 选项所提供"服务器端版本(server-side version)"。

6. 组件异步加载：
	// 这是普通的组件加载，应用程序启动后，组件就被加载了
	import Foo from './components/Foot.vue';
	// 这是按需加载，应用执行执行到此页面时， 才会去加载组件
	const Foo = () => import('./components/Foot.vue');

	Vue 2.5以下版本， 服务端渲染时异步组件只能用在路由上。
	2.5+版本， 异步组件可以用在任何地方。

	
	https://ssr.vuejs.org/zh/guide/structure.html#%E4%BD%BF%E7%94%A8-webpack-%E7%9A%84%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84

